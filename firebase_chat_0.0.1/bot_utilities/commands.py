import discord
from discord.ext import commands
from discord import app_commands
from src.memory_manager import load_active_channels, save_active_channels, load_conversation, save_conversation, add_message_to_conversation
from src.ai_chat import get_ai_response
from src.tts import get_tts_audio, cleanup_audio_file
from src.npc_manager import get_available_npcs, get_npc_prompt

# Naƒçti aktivn√≠ kan√°ly p≈ôi startu modulu
active_channels = load_active_channels()
# Naƒçti dostupn√© NPC p≈ôi startu modulu
available_npcs = get_available_npcs()
# Zvol si v√Ωchoz√≠ NPC, pokud ≈æ√°dn√© nen√≠ aktivn√≠ v kan√°lu
DEFAULT_NPC_ID = list(available_npcs.keys())[0] if available_npcs else "default" # Zvol prvn√≠ NPC nebo "default"

class BotCommands(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        # Ulo≈æ√≠me aktivn√≠ NPC pro ka≈æd√Ω kan√°l
        self.channel_npc = {} # {channel_id: npc_id}

    # Naƒçten√≠ aktivn√≠ch kan√°l≈Ø a jejich NPC p≈ôi spu≈°tƒõn√≠ bota
    @commands.Cog.listener()
    async def on_ready(self):
        print(f'P≈ôihl√°≈°en jako {self.bot.user} (ID: {self.bot.user.id})')
        print('------')
        # Synchronizace slash p≈ô√≠kaz≈Ø - d≈Øle≈æit√© pro jejich zobrazen√≠ na Discordu
        await self.bot.tree.sync()
        print("Slash p≈ô√≠kazy synchronizov√°ny.")

        # Naƒçten√≠ aktivn√≠ch kan√°l≈Ø z datab√°ze p≈ôi startu
        global active_channels
        active_channels = load_active_channels()
        print(f"Naƒçteny aktivn√≠ kan√°ly: {active_channels}")

        # Zde bys mohl naƒç√≠st i posledn√≠ aktivn√≠ NPC pro ka≈æd√Ω aktivn√≠ kan√°l z DB,
        # pokud to pot≈ôebuje≈° udr≈æovat perzistentnƒõ. Pro jednoduchost teƒè pou≈æijeme v√Ωchoz√≠.
        for channel_id in active_channels:
             # Zde by byla logika pro naƒçten√≠ preferovan√©ho NPC pro dan√Ω kan√°l, pokud existuje
             self.channel_npc[channel_id] = DEFAULT_NPC_ID # Pro zaƒç√°tek pou≈æijeme v√Ωchoz√≠

        print('Bot je p≈ôipraven!')
        # Z√°kladn√≠ info o botovi (ƒç√°steƒçn√° implementace Dashboardu)
        print("\n--- Info o Botovi ---")
        print(f"ID bota: {self.bot.user.id}")
        print(f"P≈ôipojen na {len(self.bot.guilds)} serverech.")
        print(f"Aktivn√≠ v {len(active_channels)} kan√°lech (po naƒçten√≠).")
        print(f"Dostupn√© NPC: {', '.join(available_npcs)}")
        print("----------------------")


    # Listener pro zpracov√°n√≠ zpr√°v, kdy≈æ je bot aktivn√≠ v kan√°lu
    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        # Ignoruj zpr√°vy od samotn√©ho bota nebo od webhook≈Ø
        if message.author == self.bot.user or message.webhook_id is not None:
            return

        # Zkontroluj, zda je kan√°l aktivn√≠ a zda zpr√°va nen√≠ slash p≈ô√≠kaz
        if message.channel.id in active_channels and not message.content.startswith('/'):
            channel_id = message.channel.id
            user_id = message.author.id
            npc_id = self.channel_npc.get(channel_id, DEFAULT_NPC_ID) # Z√≠skej NPC pro kan√°l, jinak v√Ωchoz√≠

            # Zkontroluj, zda existuje prompt pro vybran√© NPC
            npc_prompt = get_npc_prompt(npc_id)
            if not npc_prompt:
                 await message.channel.send(f"Promi≈à, NPC s ID `{npc_id}` nen√≠ definov√°no. Pros√≠m, vyber jin√© pomoc√≠ `/chat active <npc_id>`.")
                 return # P≈ôesta≈à zpracov√°vat zpr√°vu, pokud NPC neexistuje

            # Naƒçti historii konverzace
            conversation_history = load_conversation(npc_id, channel_id, user_id)

            # P≈ôidej syst√©movou zpr√°vu s promptem NPC na zaƒç√°tek historie pro AI
            # OpenAI API a kompatibiln√≠ obvykle pou≈æ√≠vaj√≠ role: system, user, assistant
            if not conversation_history or conversation_history[0].get('role') != 'system':
                 # P≈ôid√°me prompt jen pokud u≈æ tam nen√≠ nebo historie je pr√°zdn√°
                 conversation_history.insert(0, {"role": "system", "content": npc_prompt})

            # P≈ôidej aktu√°ln√≠ zpr√°vu u≈æivatele do historie
            conversation_history.append({"role": "user", "content": message.content})

            # Zavolej AI pro odpovƒõƒè (funkce u≈æ obsahuje indik√°tor psan√≠)
            ai_response_text = await get_ai_response(conversation_history, message.channel)

            if ai_response_text:
                # P≈ôidej odpovƒõƒè AI do historie konverzace
                conversation_history.append({"role": "assistant", "content": ai_response_text})

                # Ulo≈æ aktualizovanou konverzaci zpƒõt do datab√°ze
                # M≈Ø≈æe≈° ukl√°dat po ka≈æd√© zpr√°vƒõ, nebo po cel√© interakci, nebo po urƒçit√©m poƒçtu zpr√°v
                # save_conversation(npc_id, channel_id, user_id, conversation_history) # Ulo≈æ√≠ celou historii (potenci√°lnƒõ velkou)
                # Lep≈°√≠ je mo≈æn√° pr≈Øbƒõ≈ænƒõ p≈ôid√°vat zpr√°vy, ale z√°vis√≠ na datab√°zov√© struktu≈ôe a efektivitƒõ z√°pisu
                # add_message_to_conversation(npc_id, channel_id, user_id, {"role": "user", "content": message.content}) # P≈ô√≠klad pr≈Øbƒõ≈æn√©ho ukl√°d√°n√≠ u≈æivatelsk√© zpr√°vy
                # add_message_to_conversation(npc_id, channel_id, user_id, {"role": "assistant", "content": ai_response_text}) # P≈ô√≠klad pr≈Øbƒõ≈æn√©ho ukl√°d√°n√≠ AI odpovƒõdi
                # Pro jednoduchost v tomto p≈ô√≠kladu ukl√°d√°me celou historii po z√≠sk√°n√≠ odpovƒõdi, ale s omezen√≠m d√©lky p≈ôi naƒç√≠t√°n√≠.
                # Zde provedeme ulo≈æen√≠ cel√© (ji≈æ omezen√©) historie po z√≠sk√°n√≠ odpovƒõdi.
                save_conversation(npc_id, channel_id, user_id, conversation_history)


                # Po≈°li odpovƒõƒè AI na Discord
                await message.channel.send(ai_response_text)

                # Generuj a po≈°li TTS audio
                audio_file_path = await get_tts_audio(ai_response_text)
                if audio_file_path:
                    try:
                        # discord.File vy≈æaduje lok√°ln√≠ cestu k souboru
                        audio_file = discord.File(audio_file_path)
                        # Po≈°li audio soubor jako p≈ô√≠lohu
                        await message.channel.send(file=audio_file)
                    except Exception as e:
                        print(f"Chyba p≈ôi pos√≠l√°n√≠ audio souboru: {e}")
                    finally:
                        # Uklid doƒçasn√©ho audio souboru
                        cleanup_audio_file(audio_file_path)


    # Slash p≈ô√≠kaz /ping
    @app_commands.command(name="ping", description="Zkontroluje odezvu bota.")
    async def ping_command(self, interaction: discord.Interaction):
        # 'Graphick√Ω' design pro konzolov√©ho bota bude prostƒõ hezky form√°tovan√Ω text
        latency_ms = round(self.bot.latency * 1000, 2)
        response_text = f"```Pong! üèì\nOdezva bota: {latency_ms} ms```"
        await interaction.response.send_message(response_text, ephemeral=False) # ephemeral=True by zpr√°vu zobrazil jen u≈æivateli, kter√Ω p≈ô√≠kaz pou≈æil


    # Slash p≈ô√≠kaz /chat active/deactivate
    @app_commands.command(name="chat", description="Aktivuje/deaktivuje AI chat bota v tomto kan√°lu a volitelnƒõ nastav√≠ NPC.")
    @app_commands.describe(action="Vyber 'active' nebo 'deactivate'.", npc_id="Voliteln√©: ID NPC pro aktivaci. Nechej pr√°zdn√© pro v√Ωchoz√≠.")
    @app_commands.choices(action=[
        discord.app_commands.Choice(name="active", value="active"),
        discord.app_commands.Choice(name="deactivate", value="deactivate")
    ])
    async def chat_command(self, interaction: discord.Interaction, action: discord.app_commands.Choice[str], npc_id: str = None):
        channel_id = interaction.channel_id

        if action.value == "active":
            if channel_id in active_channels:
                 response_text = f"AI chat je ji≈æ v tomto kan√°lu aktivn√≠."
                 # Pokud bylo zad√°no NPC, zkus√≠me ho nastavit
                 if npc_id:
                      if npc_id in available_npcs:
                           self.channel_npc[channel_id] = npc_id
                           response_text += f" Bylo nastaveno NPC: **{npc_id}**."
                           # M≈Ø≈æe≈° zde ulo≈æit preferovan√© NPC pro kan√°l do DB, pokud chce≈° perzistenci
                      else:
                           response_text += f" NPC s ID `{npc_id}` neexistuje. Pou≈æ√≠v√° se aktu√°lnƒõ nastaven√© NPC ({self.channel_npc.get(channel_id, DEFAULT_NPC_ID)})."
                 else:
                      response_text += f" Pou≈æ√≠v√° se aktu√°ln√≠ NPC ({self.channel_npc.get(channel_id, DEFAULT_NPC_ID)})."


            else:
                active_channels.add(channel_id)
                save_active_channels(active_channels) # Ulo≈æ zmƒõnu do DB
                response_text = f"AI chat byl v tomto kan√°lu **aktivov√°n**."
                # Nastav NPC
                if npc_id and npc_id in available_npcs:
                     self.channel_npc[channel_id] = npc_id
                     response_text += f" Bylo nastaveno NPC: **{npc_id}**."
                else:
                    # Pou≈æij v√Ωchoz√≠ nebo aktu√°ln√≠ pro kan√°l (pokud ji≈æ existuje z√°znam)
                    if channel_id in self.channel_npc:
                         # Kan√°l byl neaktivn√≠, ale mƒõl nastaven√© NPC, pou≈æijeme ho
                         used_npc_id = self.channel_npc[channel_id]
                         response_text += f" Pou≈æ√≠v√° se d≈ô√≠ve nastaven√© NPC: **{used_npc_id}**."
                    else:
                        # Kan√°l se aktivuje poprv√© nebo nemƒõl nastaven√© NPC, pou≈æijeme v√Ωchoz√≠
                        self.channel_npc[channel_id] = DEFAULT_NPC_ID
                        response_text += f" Bylo nastaveno **v√Ωchoz√≠** NPC: **{DEFAULT_NPC_ID}**."

                # Zde bys mohl ulo≈æit preferovan√© NPC pro kan√°l do DB, pokud chce≈° perzistenci


        elif action.value == "deactivate":
            if channel_id in active_channels:
                active_channels.remove(channel_id)
                save_active_channels(active_channels) # Ulo≈æ zmƒõnu do DB
                response_text = f"AI chat byl v tomto kan√°lu **deaktivov√°n**."
                # M≈Ø≈æe≈° zde zv√°≈æit smaz√°n√≠ z√°znamu o preferovan√©m NPC pro kan√°l z DB, pokud chce≈° perzistenci
            else:
                response_text = f"AI chat nen√≠ v tomto kan√°lu aktivn√≠."

        await interaction.response.send_message(response_text, ephemeral=False)

    # Auto-complete pro npc_id v p≈ô√≠kazu /chat active
    @chat_command.autocomplete('npc_id')
    async def chat_npc_autocomplete(self, interaction: discord.Interaction, current: str):
        # Nab√≠dne dostupn√© NPC, kter√© se shoduj√≠ s t√≠m, co u≈æivatel p√≠≈°e
        return [
            app_commands.Choice(name=npc_id, value=npc_id)
            for npc_id in available_npcs if current.lower() in npc_id.lower()
        ][:25] # Omez√≠me poƒçet nab√≠dek na 25, limit Discordu


    # Zde bys mohl p≈ôidat dal≈°√≠ p≈ô√≠kazy, nap≈ô. pro zobrazen√≠ aktu√°ln√≠ho NPC v kan√°lu, smaz√°n√≠ pamƒõti atd.
    @app_commands.command(name="current_npc", description="Zobraz√≠ aktu√°lnƒõ aktivn√≠ NPC v tomto kan√°lu.")
    async def current_npc_command(self, interaction: discord.Interaction):
        channel_id = interaction.channel_id
        if channel_id in active_channels:
            current_npc = self.channel_npc.get(channel_id, DEFAULT_NPC_ID)
            await interaction.response.send_message(f"Aktu√°lnƒõ aktivn√≠ NPC v tomto kan√°lu je: **{current_npc}**", ephemeral=False)
        else:
            await interaction.response.send_message("AI chat nen√≠ v tomto kan√°lu aktivn√≠.", ephemeral=False)

    @app_commands.command(name="list_npcs", description="Zobraz√≠ seznam dostupn√Ωch NPC.")
    async def list_npcs_command(self, interaction: discord.Interaction):
        if available_npcs:
            npc_list = ", ".join(available_npcs)
            await interaction.response.send_message(f"Dostupn√° NPC: {npc_list}", ephemeral=False)
        else:
            await interaction.response.send_message("Nebyly nalezeny ≈æ√°dn√© definice NPC v souboru NPC.txt.", ephemeral=False)

    # P≈ô√≠kaz pro smaz√°n√≠ pamƒõti pro aktu√°ln√≠ho u≈æivatele a NPC v kan√°lu (pro ladƒõn√≠ nebo reset)
    @app_commands.command(name="reset_memory", description="Sma≈æe pamƒõ≈• pro aktu√°ln√≠ NPC a u≈æivatele v tomto kan√°lu.")
    async def reset_memory_command(self, interaction: discord.Interaction):
        channel_id = interaction.channel_id
        user_id = interaction.user.id
        npc_id = self.channel_npc.get(channel_id, DEFAULT_NPC_ID)

        try:
            ref = db.reference(f'{MEMORY_DB_PATH}/{npc_id}/{channel_id}/{user_id}')
            ref.set(None) # Nastaven√≠m na None se z√°znam sma≈æe
            await interaction.response.send_message(f"Pamƒõ≈• pro NPC `{npc_id}` a u≈æivatele **{interaction.user.display_name}** v tomto kan√°lu byla smaz√°na.", ephemeral=False)
            print(f"Pamƒõ≈• smaz√°na pro NPC {npc_id}, kan√°l {channel_id}, u≈æivatele {user_id}") # Ladic√≠ v√Ωpis
        except Exception as e:
            print(f"Chyba p≈ôi maz√°n√≠ pamƒõti: {e}")
            await interaction.response.send_message("Do≈°lo k chybƒõ p≈ôi maz√°n√≠ pamƒõti. üò•", ephemeral=False)